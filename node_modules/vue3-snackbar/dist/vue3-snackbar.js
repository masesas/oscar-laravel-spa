import { h as p, computed as u, ref as N, onMounted as A, watch as F, openBlock as f, createElementBlock as b, normalizeClass as T, unref as c, normalizeStyle as O, renderSlot as h, createElementVNode as y, createVNode as $, mergeProps as P, createCommentVNode as S, toDisplayString as L, inject as Z, onUnmounted as G, createBlock as V, Teleport as q, TransitionGroup as R, withCtx as B, Fragment as U, renderList as H, createSlots as J, normalizeProps as K, guardReactiveProps as Q } from "vue";
var W = "M8.27,3L3,8.27V15.73L8.27,21H15.73C17.5,19.24 21,15.73 21,15.73V8.27L15.73,3M9.1,5H14.9L19,9.1V14.9L14.9,19H9.1L5,14.9V9.1M11,15H13V17H11V15M11,7H13V13H11V7", X = "M12,2L1,21H23M12,6L19.53,19H4.47M11,10V14H13V10M11,16V18H13V16", Y = "M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z", ee = "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z", se = "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z";
const te = {
  transform: "rotate(var(--r, 0deg)) scale(var(--sx, 1), var(--sy, 1))"
}, z = {
  fill: "currentColor"
}, I = {
  mdi: {
    size: 24,
    viewbox: "0 0 24 24"
  },
  "simple-icons": {
    size: 24,
    viewbox: "0 0 24 24"
  },
  default: {
    size: 0,
    viewbox: "0 0 0 0"
  }
}, E = {
  name: "icon",
  props: {
    type: {
      type: String,
      default: "mdi"
    },
    faIcon: {
      type: Object,
      default: null
    },
    path: {
      type: [String, Object, Array]
    },
    size: {
      type: [Number, String],
      default: 24
    },
    viewbox: String,
    flip: {
      type: String,
      validator: (s) => ["horizontal", "vertical", "both"].includes(s)
    },
    rotate: {
      type: [Number, String],
      default: 0
    }
  },
  setup(s) {
    if (!s.path && !s.faIcon)
      return console.warn("vue3-icon requires either a 'path' or an 'fa-icon' property"), () => p("div");
    const r = u(() => {
      var n;
      return ((n = s.faIcon) == null ? void 0 : n.prefix) || s.type;
    }), e = u(() => parseInt(s.rotate, 10)), t = u(() => I[r.value] || I.default), i = u(() => parseInt(s.size, 10) || t.value.size), l = u(() => s.faIcon ? `0 0 ${s.faIcon.icon[0]} ${s.faIcon.icon[1]}` : !1), d = u(() => l.value || s.viewbox || t.value.viewbox), m = u(() => ({
      ...te,
      "--sx": ["both", "horizontal"].includes(s.flip) ? "-1" : "1",
      "--sy": ["both", "vertical"].includes(s.flip) ? "-1" : "1",
      "--r": isNaN(e.value) ? e.value : e.value + "deg"
    })), v = u(() => {
      var n;
      return s.faIcon ? (n = s.faIcon) == null ? void 0 : n.icon[4] : s.type === "simple-icons" && typeof s.path == "object" ? s.path.path : s.path;
    }), a = u(() => r.value === "fad" ? (console.warn("vue3-icon does not currently support Duotone FontAwesome icons"), p("path")) : Array.isArray(s.path) ? p(
      "g",
      { style: { ...z } },
      s.path.map((n) => typeof n == "string" ? p("path", { d: n }) : p("path", { ...n }))
    ) : p("path", { d: v.value, style: { ...z } }));
    return () => p(
      "svg",
      {
        style: m.value,
        class: ["vue3-icon"],
        width: i.value,
        height: i.value,
        viewBox: d.value
      },
      [a.value]
    );
  }
}, ae = { class: "vue3-snackbar-message-wrapper" }, oe = {
  key: 0,
  class: "vue3-snackbar-message-icon"
}, re = { class: "vue3-snackbar-message-content" }, ne = {
  key: 0,
  class: "vue3-snackbar-message-badge"
}, ie = { class: "vue3-snackbar-message-title" }, le = {
  key: 0,
  class: "vue3-snackbar-message-additional"
}, ue = /* @__PURE__ */ y("div", { class: "spacer" }, null, -1), ce = { class: "vue3-snackbar-message-close" }, de = {
  __name: "Vue3SnackbarMessage",
  props: {
    borderClass: {
      type: String,
      default: ""
    },
    message: {
      type: Object,
      default: () => ({})
    },
    messageClass: {
      type: String,
      default: ""
    },
    dense: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["dismiss"],
  setup(s, { emit: r }) {
    const e = s;
    let t = null, i = null, l = N(!1);
    const d = () => {
      const o = !e.message.duration && !e.message.dismissible ? 4e3 : e.message.duration;
      t = setTimeout(v, o);
    };
    A(() => {
      d();
    }), F(
      () => e.message.count,
      (o) => {
        if (o === 1)
          return !1;
        clearTimeout(t), clearTimeout(i), i = setTimeout(() => {
          l.value = !1;
        }, 1e3), l.value = !0, d();
      }
    );
    const m = () => {
      t && clearTimeout(t), v();
    }, v = () => {
      r("dismiss", e.message);
    }, a = {
      success: {
        path: Y
      },
      info: {
        path: se
      },
      warning: {
        path: X
      },
      error: {
        path: W
      }
    }, n = u(() => {
      const o = a[e.message.type];
      return o ? (o.type = "mdi", o) : e.message.icon && typeof e.message.icon == "object" ? e.message.icon : {
        path: "",
        type: "default"
      };
    });
    return (o, w) => (f(), b("article", {
      class: T(["vue3-snackbar-message", [
        e.message.type || "custom",
        e.messageClass,
        e.borderClass,
        {
          "has-background": e.message.background,
          "has-border": e.borderClass,
          "is-dense": e.dense,
          "shake-baby-shake": c(l)
        }
      ]]),
      style: O({
        "--message-background": e.message.background
      })
    }, [
      h(o.$slots, "message-inner", {
        message: e.message
      }, () => [
        y("div", ae, [
          c(n) ? (f(), b("div", oe, [
            h(o.$slots, "message-icon", {
              message: e.message,
              icon: c(n)
            }, () => [
              $(c(E), P(c(n), { role: "img" }), null, 16)
            ])
          ])) : S("", !0),
          y("div", re, [
            h(o.$slots, "message-badge", {
              message: e.message,
              count: e.message.count
            }, () => [
              e.message.count > 1 ? (f(), b("div", ne, L(e.message.count), 1)) : S("", !0)
            ]),
            h(o.$slots, "message-content", {
              message: e.message,
              title: e.message.title,
              text: e.message.text
            }, () => [
              y("div", ie, L(e.message.title || e.message.text), 1),
              e.message.title && e.message.text ? (f(), b("div", le, L(e.message.text), 1)) : S("", !0)
            ])
          ]),
          ue,
          y("div", ce, [
            e.message.dismissible !== !1 ? (f(), b("button", {
              key: 0,
              onClick: m
            }, [
              h(o.$slots, "message-close-icon", {
                message: e.message
              }, () => [
                $(c(E), {
                  type: "mdi",
                  path: c(ee)
                }, null, 8, ["path"])
              ])
            ])) : S("", !0)
          ])
        ])
      ])
    ], 6));
  }
}, fe = typeof window < "u" ? HTMLElement : Object, pe = {
  /* ******************************************
   * LOCATION PROPS
   ****************************************** */
  /**
   * Render the snackbar at the top of the screen
   */
  top: {
    type: Boolean,
    default: !1
  },
  /**
   * Render the snackbar at the bottom of the screen
   */
  bottom: {
    type: Boolean,
    default: !1
  },
  /**
   * Render the snackbar on the left of the screen
   */
  left: {
    type: Boolean,
    default: !1
  },
  /**
   * Render the snackbar on the right of the screen
   */
  right: {
    type: Boolean,
    default: !1
  },
  /* ******************************************
   * COLOUR PROPS
   ****************************************** */
  success: {
    type: String,
    default: "#4caf50"
  },
  error: {
    type: String,
    default: "#ff5252"
  },
  warning: {
    type: String,
    default: "#fb8c00"
  },
  info: {
    type: String,
    default: "#2196f3"
  },
  /* ******************************************
   * OTHER PROPS
   ****************************************** */
  /**
   * The element to teleport the snackbar container to
   */
  attach: {
    type: [String, fe],
    default: "body"
  },
  /**
   * Use the alternate border style for messages
   */
  border: {
    type: String,
    default: "",
    validator: (s) => ["top", "bottom", "left", "right", ""].includes(s)
  },
  /**
   * The background colour opacity when using border-style messages
   */
  backgroundOpacity: {
    type: [String, Number],
    default: 0.12,
    validator: (s) => !isNaN(parseFloat(s)) && isFinite(s)
  },
  /**
   * Background colour when using border-style messages
   */
  backgroundColor: {
    type: String,
    default: "currentColor"
  },
  /**
   * Background colour when using border-style messages
   */
  baseBackgroundColor: {
    type: String,
    default: "#fff"
  },
  /**
   * The default time in ms for messages to stay on the screen
   */
  duration: {
    type: Number,
    default: null
  },
  /**
   * Class string to add to each message
   */
  messageClass: {
    type: String
  },
  /**
   * The z-index value of the snackbar container
   */
  zIndex: {
    type: Number,
    default: 1e4
  },
  /**
   * Reduce padding on the y-axis for snackbar messages
   */
  dense: {
    type: Boolean,
    default: !1
  },
  /**
   * Reverse the display order of snackbar messages
   */
  reverse: {
    type: Boolean,
    default: !1
  },
  /**
   * Use snackbar groups with messages with the same group-key
   */
  groups: {
    type: Boolean,
    default: !1
  },
  /**
   * Add shadow effect to messages
   */
  shadow: {
    type: Boolean,
    default: !1
  }
};
var _ = {}, ge = {
  get exports() {
    return _;
  },
  set exports(s) {
    _ = s;
  }
};
function x() {
}
x.prototype = {
  on: function(s, r, e) {
    var t = this.e || (this.e = {});
    return (t[s] || (t[s] = [])).push({
      fn: r,
      ctx: e
    }), this;
  },
  once: function(s, r, e) {
    var t = this;
    function i() {
      t.off(s, i), r.apply(e, arguments);
    }
    return i._ = r, this.on(s, i, e);
  },
  emit: function(s) {
    var r = [].slice.call(arguments, 1), e = ((this.e || (this.e = {}))[s] || []).slice(), t = 0, i = e.length;
    for (t; t < i; t++)
      e[t].fn.apply(e[t].ctx, r);
    return this;
  },
  off: function(s, r) {
    var e = this.e || (this.e = {}), t = e[s], i = [];
    if (t && r)
      for (var l = 0, d = t.length; l < d; l++)
        t[l].fn !== r && t[l].fn._ !== r && i.push(t[l]);
    return i.length ? e[s] = i : delete e[s], this;
  }
};
ge.exports = x;
_.TinyEmitter = x;
var me = _, C = new me();
const k = {
  $on: (...s) => C.on(...s),
  $once: (...s) => C.once(...s),
  $off: (...s) => C.off(...s),
  $emit: (...s) => C.emit(...s)
}, g = N([]), j = Symbol();
function be() {
  const s = Z(j);
  if (!s)
    throw new Error("No Snackbar provided!");
  return s;
}
const he = {
  install: (s) => {
    const r = {
      add: (e) => {
        k.$emit("add", e);
      },
      clear: () => {
        k.$emit("clear");
      }
    };
    s.config.globalProperties.$snackbar = r, typeof window < "u" && (window.$snackbar = r), s.provide(j, r);
  }
};
const ye = {
  __name: "Vue3Snackbar",
  props: { ...pe },
  emits: ["added", "dismissed", "removed", "cleared"],
  setup(s, { emit: r }) {
    const e = s, t = u(() => ({
      "is-top": e.top,
      "is-bottom": e.top === !1 && e.bottom,
      "is-left": e.left,
      "is-right": e.left === !1 && e.right,
      "is-middle": e.top === !1 && e.bottom === !1,
      "is-centre": e.left === !1 && e.right === !1,
      "has-shadow": e.shadow
    })), i = u(() => ({
      "--success-colour": e.success,
      "--error-colour": e.error,
      "--warning-colour": e.warning,
      "--info-colour": e.info,
      "--snackbar-zindex": e.zIndex,
      "--background-opacity": e.backgroundOpacity,
      "--background-color": e.backgroundColor,
      "--base-background-color": e.baseBackgroundColor
    })), l = u(() => e.border ? `border-${e.border}` : ""), d = (a) => Math.abs(a.split("").reduce((n, o) => (n << 5) - n + o.charCodeAt(0) | 0, 0));
    let m = 1;
    A(() => {
      k.$on("add", (a) => {
        r("added", a), a.group || (a.group = d(`${a.type}${a.title}${a.text}`).toString(16)), e.duration && !a.duration && a.duration !== 0 && (a.duration = e.duration);
        const n = a.group && g.value.find((o) => o.group === a.group);
        if (e.groups === !1 || !n) {
          const o = {
            ...a,
            id: m,
            count: 1
          };
          e.reverse ? g.value.unshift(o) : g.value.push(o), m++;
        } else
          n.count++;
      }), k.$on("clear", () => {
        r("cleared"), g.value = [];
      });
    }), G(() => {
      k.$off("add"), k.$off("clear");
    });
    const v = (a, n = !1) => {
      r(n ? "dismissed" : "removed", a), g.value = g.value.filter((o) => o.id !== a.id);
    };
    return (a, n) => (f(), V(q, {
      to: e.attach
    }, [
      y("section", {
        id: "vue3-snackbar--container",
        class: T([[c(t)], "vue3-snackbar"]),
        style: O(c(i))
      }, [
        $(R, {
          name: "vue3-snackbar-message",
          tag: "div"
        }, {
          default: B(() => [
            (f(!0), b(U, null, H(c(g), (o) => (f(), V(de, {
              key: o.id,
              message: o,
              "message-class": e.messageClass,
              dense: e.dense,
              "border-class": c(l),
              onDismiss: n[0] || (n[0] = (w) => v(w, !0))
            }, J({ _: 2 }, [
              H(a.$slots, (w, M) => ({
                name: M,
                fn: B((D) => [
                  h(a.$slots, M, K(Q(D)))
                ])
              }))
            ]), 1032, ["message", "message-class", "dense", "border-class"]))), 128))
          ]),
          _: 3
        })
      ], 6)
    ], 8, ["to"]));
  }
};
export {
  g as SnackbarMessages,
  he as SnackbarService,
  ye as Vue3Snackbar,
  be as useSnackbar
};
